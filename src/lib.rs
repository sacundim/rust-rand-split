// Copyright 2016 Luis Casillas. See the COPYRIGHT file at the
// top-level directory of this distribution
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A crate to support **splittable** random number generators.
//!
//! These are genertors that support a "split" operation that produces
//! two or more "child" generators whose initial state depends on the
//! source RNG's state, but produce outputs that are uncorrelated to
//! each other.  This can be useful in some contexts:
//!
//! * Functional programs sometimes make good use of splittable RNGs.  The
//!   Haskell [QuickCheck](https://hackage.haskell.org/package/QuickCheck) 
//!   library is a notable example that uses a splittable, pure-functional
//!   PRNG to support random generation of deterministic functions.
//! * Parallel programs may benefit from a splittable PRNG.  The
//!   advantage isn't necessarily performance but rather
//!   **reproducibility**; it makes it easier to guarantee that using
//!   the same seed yields the same results even if the execution order
//!   is nondeterministic.
//!
//! References:
//!
//! * Claessen, Koen and Michał H. Pałka.  2013.  ["Splittable
//!   Pseudorandom Number Generators using Cryptographic
//!   Hashing."](http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf)
//!   *Haskell '13: Proceedings of the 2013 ACM SIGPLAN symposium on
//!   Haskell*, pp. 47-58.
//! * Schaathun, Hans Georg.  2015.  ["Evaluation of Splittable
//!   Pseudo-Random
//!   Generators."](http://www.hg.schaathun.net/research/Papers/hgs2015jfp.pdf)
//!   *Journal of Functional Programming*, Vol. 25.
//! * The Haskell [`tf-random` library](https://hackage.haskell.org/package/tf-random).


extern crate rand;

pub mod generic;
pub mod siprng;

use rand::{Rng, Rand};
use siprng::{SipRng, SipPrf};
use std::hash::{Hash, Hasher, SipHasher};


/// A trait for **splittable** pseudo random generators.  
pub trait SplitRng : Rng + Sized {
    
    /// The type of pseudo-random functions ("PRFs") produced off a
    /// `SplitRng` instance.  A PRF is a factory of `SplitRng`s, whose
    /// initial states are determined by two values:
    ///
    /// 1. The state of the `SplitRng` when the PRF was created;
    /// 2. The argument to the PRF.
    ///
    /// Note that while the term *pseudo-random function* has a
    /// technical meaning in cryptograpy, **no security claim is
    /// implied here**.
    type Prf : SplitPrf<Self>;
    
    /// Turn this generator into a pseudo-random function.
    ///
    /// The original generator is moved into this function, and can
    /// then no longer be reused.  This is deliberate; the Claessen &
    /// Pałka splittable RNG construction requires this.
    fn splitn(self) -> Self::Prf;
    
    /// Split this random number generator into two children.  This
    /// has a default implementation in terms of `splitn`.
    fn split(self) -> (Self, Self) {
        let prf: Self::Prf = self.splitn();
        (prf.call(0), prf.call(1))
    }
    
}

/// The trait implemented by the pseudo-random functions generated off
/// a `SplitRng`.  These objects act as immutable factories for
/// `SplitRng` instances, accessed by supplying an `usize` index.
pub trait SplitPrf<Rng> {
    /// Instantiate the `i`th branch of the captured `SplitRng`.
    ///
    /// Note that instantiating the same `i` multiple times is
    /// allowed, and they all start from the same state.  This is
    /// useful in some cases; for example, random generation of
    /// deterministic functions (like Haskell's QuickCheck library
    /// does).
    fn call(&self, i: u64) -> Rng;
}


/// A wrapper that generically adds splittability to RNGs.
pub type Split<Rng> = generic::Split<SipRng, Rng>;

/// The pseudo-random functions of a generic `Split` RNG.
pub type Prf<Rng> = generic::Prf<SipPrf, Rng>;


/// A type that can be randomly generated by splitting a `SplitRand`.
pub trait SplitRand {
    
    /// Generates a random instance of this type by splitting the
    /// given `SplitRng`.  Note that the RNG is moved into this
    /// function.
    fn rand<R: SplitRng>(rng: R) -> Self;
    
}

impl<A: Hash, B: Rand> SplitRand for Box<Fn(A) -> B> {
    
    fn rand<R>(rng: R) -> Self 
        where R: SplitRng, R: 'static
    {
        #[inline]
        fn hash<T: Hash>(t: &T) -> u64 {
            let mut s = SipHasher::new();
            t.hash(&mut s);
            s.finish()
        }
        
        let prf = rng.splitn();
        Box::new(move |arg: A| {
            Rand::rand(&mut prf.call(hash(&arg)))
        })
    }

}

macro_rules! postincrement {
    ($i:expr) => {
        {let _j = $i; $i += 1; _j}
    }
}

// Adapted, with minor modifications, from the `rand` crate.
macro_rules! tuple_impl {
    // use variables to indicate the arity of the tuple
    ($($tyvar:ident),* ) => {
        // the trailing commas are for the 1 tuple
        impl<
            $( $tyvar : Rand ),*
            > SplitRand for ( $( $tyvar ),* , ) {

            #[inline]
            fn rand<R: SplitRng>(_rng: R) -> ( $( $tyvar ),* , ) {
                let prf = _rng.splitn();
                let mut _i: u64 = 0;
                (
                    // use the $tyvar's to get the appropriate number of
                    // repeats (they're not actually needed)
                    $(
                        prf.call(postincrement!(_i)).gen::<$tyvar>()
                    ),*
                    ,
                )
            }
        }
    }
}

tuple_impl!{A, B}
tuple_impl!{A, B, C}
tuple_impl!{A, B, C, D}
tuple_impl!{A, B, C, D, E}
tuple_impl!{A, B, C, D, E, F}
tuple_impl!{A, B, C, D, E, F, G}
tuple_impl!{A, B, C, D, E, F, G, H}
tuple_impl!{A, B, C, D, E, F, G, H, I}
tuple_impl!{A, B, C, D, E, F, G, H, I, J}
tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}
tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}


// Adapted, with minor modifications, from the `rand` crate.
macro_rules! array_impl {
    {$n:expr, $t:ident, $($ts:ident,)*} => {
        array_impl!{($n - 1), $($ts,)*}

        impl<T> SplitRand for [T; $n] where T: Rand {
            #[inline]
            fn rand<R: SplitRng>(_rng: R) -> [T; $n] {
                let prf = _rng.splitn();
                let mut _i: u64 = 0;
                [
                    prf.call(postincrement!(_i)).gen::<$t>(), 
                    $(prf.call(postincrement!(_i)).gen::<$ts>()),*
                ]
            }
        }
    };
    {$n:expr,} => {
        impl<T> SplitRand for [T; $n] {
            fn rand<R: SplitRng>(_rng: R) -> [T; $n] { [] }
        }
    };
}

array_impl!{
    32, 
    T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
    T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
}


#[cfg(test)]
mod tests {

    #[test]
    fn test_postincrement() {
        let mut _i = 0;
        assert_eq!((0, 1, 2, 3), 
                   (postincrement!(_i),
                    postincrement!(_i),
                    postincrement!(_i),
                    postincrement!(_i)))
    }

}
