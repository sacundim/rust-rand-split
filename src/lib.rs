// Copyright 2016 Luis Casillas. See the COPYRIGHT file at the
// top-level directory of this distribution
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A crate to support **splittable** random number generators.
//!
//! These are genertors that support a "split" operation that produces
//! two or more "child" generators whose initial state depends on the
//! source RNG's state, but produce outputs that are uncorrelated to
//! each other.  This can be useful in some contexts:
//!
//! * Functional programs sometimes make good use of splittable RNGs.  The
//!   Haskell [QuickCheck](https://hackage.haskell.org/package/QuickCheck) 
//!   library is a notable example that uses a splittable, pure-functional
//!   PRNG to support random generation of deterministic functions.
//! * Parallel programs may benefit from a splittable PRNG.  The
//!   advantage isn't necessarily performance but rather
//!   **reproducibility**; it makes it easier to guarantee that using
//!   the same seed yields the same results even if the execution order
//!   is nondeterministic.
//!
//! References:
//!
//! * Claessen, Koen and Michał H. Pałka.  2013.  ["Splittable
//!   Pseudorandom Number Generators using Cryptographic
//!   Hashing."](http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf)
//!   *Haskell '13: Proceedings of the 2013 ACM SIGPLAN symposium on
//!   Haskell*, pp. 47-58.
//! * Schaathun, Hans Georg.  2015.  ["Evaluation of Splittable
//!   Pseudo-Random
//!   Generators."](http://www.hg.schaathun.net/research/Papers/hgs2015jfp.pdf)
//!   *Journal of Functional Programming*, Vol. 25.
//! * The Haskell [`tf-random` library](https://hackage.haskell.org/package/tf-random).


extern crate rand;

pub mod generic;
pub mod siprng;

use rand::{Rng, Rand};
use siprng::{SipRng, SipRngBranch};
use std::hash::{Hash, Hasher, SipHasher};


/// A trait for **splittable** pseudo random generators.  
pub trait SplitRng : Rng + Sized {
    
    /// The type of branches produced off a `SplitRng` instance.  A
    /// branch is an immutable object that captures the state of the
    /// RNG at the branching point, and serves as a factory for
    /// constructing RNGs for the "children."
    type Branch : RngBranch<Self>;
    
    /// Split this generator into branches.  Each branch is accessible
    /// from the resulting `Branch` object as a unique `usize` index.
    ///
    /// The original generator is moved into this function, and can
    /// then no longer be reused.  This is deliberate; the Claessen &
    /// Pałka splittable RNG construction requires this.
    ///
    /// But note that the `Branch` object returned from here supports
    /// instantiating the same branch multiple times.  This is also
    /// deliberate.
    fn splitn(self) -> Self::Branch;
    
    /// Split this random number generator into two children.  This
    /// has a default implementation in terms of `splitn`.
    fn split(self) -> (Self, Self) {
        let branches: Self::Branch = self.splitn();
        (branches.branch(0), branches.branch(1))
    }
    
}

/// The trait implemented by the branches of a `SplitRng`.  These
/// objects act as immutable factories for `SplitRng` instances,
/// accessed by supplying an `usize` index.
pub trait RngBranch<R> {
    /// Instantiate the `i`th branch of the captured `SplitRng`.
    ///
    /// Note that instantiating the same `i` multiple times is
    /// allowed, and they all start from the same state.  This is
    /// useful in some cases; for example, random generation of
    /// deterministic functions (like Haskell's QuickCheck library
    /// does).
    fn branch(&self, i: usize) -> R;
}


/// A wrapper that generically adds splittability to RNGs.
pub type Split<R> = generic::Split<SipRng, R>;

/// A branch of a generic `Split` RNG.
pub type Branch<R> = generic::Branch<SipRngBranch, R>;


/// A type that can be randomly generated by splitting a `SplitRand`.
///
/// The "killer app" for this trait is pseudo-random generation of
/// deterministic closures.  Yes, you read that right:
///
/// * Each generated closure is **deterministic**: it maps equal
///   arguments to equal results on succesive calls.
/// * The generated closures are **pseudo-random**: the deterministic
///   mapping that each one implements is pseudo-randomly chosen.
///
/// This works because an `RngBranch` is a deterministic factory of
/// `SplitRng`s--it's a function from branch numbers to `SplitRng`s at
/// their initial states.
///
/// **This feature is experimental, and its API may change.**
pub trait SplitRand {
    
    /// Generates a random instance of this type by splitting the
    /// given `SplitRng`.  Note that the RNG is moved into this
    /// function.
    fn rand<R: SplitRng>(rng: R) -> Self;
    
}

impl<A: Hash, B: Rand> SplitRand for Box<Fn(A) -> B> {
    
    fn rand<R>(rng: R) -> Self 
        where R: SplitRng, R: 'static
    {
        #[inline]
        fn hash<T: Hash>(t: &T) -> u64 {
            let mut s = SipHasher::new();
            t.hash(&mut s);
            s.finish()
        }
        
        let branch = rng.splitn();
        Box::new(move |arg: A| {
            Rand::rand(&mut branch.branch(hash(&arg) as usize))
        })
    }

}

macro_rules! postincrement {
    ($i:expr) => {
        {let _j = $i; $i += 1; _j}
    }
}

// Adapted, with minor modifications, from the `rand` crate.
macro_rules! tuple_impl {
    // use variables to indicate the arity of the tuple
    ($($tyvar:ident),* ) => {
        // the trailing commas are for the 1 tuple
        impl<
            $( $tyvar : Rand ),*
            > SplitRand for ( $( $tyvar ),* , ) {

            #[inline]
            fn rand<R: SplitRng>(_rng: R) -> ( $( $tyvar ),* , ) {
                let branches = _rng.splitn();
                let mut _i: usize = 0;
                (
                    // use the $tyvar's to get the appropriate number of
                    // repeats (they're not actually needed)
                    $(
                        branches.branch(postincrement!(_i)).gen::<$tyvar>()
                    ),*
                    ,
                )
            }
        }
    }
}

tuple_impl!{A, B}
tuple_impl!{A, B, C}
tuple_impl!{A, B, C, D}
tuple_impl!{A, B, C, D, E}
tuple_impl!{A, B, C, D, E, F}
tuple_impl!{A, B, C, D, E, F, G}
tuple_impl!{A, B, C, D, E, F, G, H}
tuple_impl!{A, B, C, D, E, F, G, H, I}
tuple_impl!{A, B, C, D, E, F, G, H, I, J}
tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}
tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}


// Adapted, with minor modifications, from the `rand` crate.
macro_rules! array_impl {
    {$n:expr, $t:ident, $($ts:ident,)*} => {
        array_impl!{($n - 1), $($ts,)*}

        impl<T> SplitRand for [T; $n] where T: Rand {
            #[inline]
            fn rand<R: SplitRng>(_rng: R) -> [T; $n] {
                let branches = _rng.splitn();
                let mut _i: usize = 0;
                [
                    branches.branch(postincrement!(_i)).gen::<$t>(), 
                    $(branches.branch(postincrement!(_i)).gen::<$ts>()),*
                ]
            }
        }
    };
    {$n:expr,} => {
        impl<T> SplitRand for [T; $n] {
            fn rand<R: SplitRng>(_rng: R) -> [T; $n] { [] }
        }
    };
}

array_impl!{
    32, 
    T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
    T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
}


#[cfg(test)]
mod tests {

    #[test]
    fn test_postincrement() {
        let mut _i = 0;
        assert_eq!((0, 1, 2, 3), 
                   (postincrement!(_i),
                    postincrement!(_i),
                    postincrement!(_i),
                    postincrement!(_i)))
    }

}
