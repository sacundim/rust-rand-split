<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `rand_split` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, rand_split">

    <title>rand_split - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'rand_split', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>rand_split</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/rand_split/src/lib.rs.html#10-538' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Splittable pseudo-random number generators.</p>

<p>These are generators that support a <strong>split</strong> operations that
forks one or more &quot;child&quot; generators off the parent.  Children&#39;s
initial states depend on the source RNG&#39;s state, but they produce
outputs that are uncorrelated to each other.  This can be useful
in some contexts:</p>

<ul>
<li>Functional programs sometimes make good use of splittable RNGs.  The
Haskell <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> 
library is a notable example that uses a splittable, pure-functional
PRNG to support random generation of deterministic functions.</li>
<li>Parallel programs may benefit from a splittable PRNG.  The
advantage isn&#39;t necessarily performance but rather
<strong>reproducibility</strong>; it makes it easier to guarantee that using
the same seed yields the same results even if the execution order
is nondeterministic.</li>
</ul>

<h2 id='motivation' class='section-header'><a href='#motivation'>Motivation</a></h2>
<p>Splittable PRNGs offer superior <strong>reproducibility</strong> in some
scenarios.  Consider a case where you are randomly generating a
pair of <code>Rand</code> instances with a conventional, i.e. <strong>sequential</strong>
PRNG:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rng</span> <span class='op'>=</span> <span class='ident'>new_sequential_rng</span>();
<span class='kw'>let</span> (<span class='ident'>a</span>, <span class='ident'>b</span>): (<span class='ident'>T1</span>, <span class='ident'>T2</span>) <span class='op'>=</span> <span class='ident'>Rand</span>::<span class='ident'>rand</span>(<span class='ident'>rng</span>);</pre>

<p>With a sequential generator, the way this is generated typically
is so:</p>

<ol>
<li>The <code>rng</code> starts at some initial state.  Call this state <code>s0</code>.</li>
<li>We use <code>rng</code> to generate a random <code>a</code>.  This leaves the <code>rng</code>
in some state, call it <code>s1</code>.</li>
<li>We reuse <code>rng</code> to generate a random <code>b</code>.  This leaves the <code>rng</code>
in some state, call it <code>s2</code>.</li>
</ol>

<p>Now, if the logic that generates the <code>a</code> value changes, then
states <code>s1</code> may end up different even if we start from the same
<code>s0</code>, which means that the value generated for <code>b</code> may also
change.</p>

<p>With a splittable PRNG, you can generate the tuple&#39;s elements with
<strong>independent</strong> PRNGs split off the parent, so that changes to the
logic that generates one element cannot affect the other.  This
can be illustrated with our flagship unit test:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand_split</span>;

<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>Rng</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::<span class='ident'>os</span>::<span class='ident'>OsRng</span>;
<span class='kw'>use</span> <span class='ident'>rand_split</span>::{<span class='ident'>SplitRng</span>, <span class='ident'>SplitPrf</span>, <span class='ident'>SplitRand</span>};
<span class='kw'>use</span> <span class='ident'>rand_split</span>::<span class='ident'>siprng</span>::{<span class='ident'>SipRng</span>, <span class='ident'>SipPrf</span>};

<span class='doccomment'>/// When generating a pair with `SplitRand`, the value generated</span>
<span class='doccomment'>/// at each position in the pair should not be affected by how</span>
<span class='doccomment'>/// much randomness was consumed by the generation of the other.</span>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>osrng</span> <span class='op'>=</span> <span class='ident'>OsRng</span>::<span class='ident'>new</span>().<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Could not create OsRng&quot;</span>);
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rng</span>: <span class='ident'>SipRng</span> <span class='op'>=</span> <span class='ident'>osrng</span>.<span class='ident'>gen</span>();

    <span class='comment'>// First we split off a **pseudo-random function** (&quot;PRF&quot;)</span>
    <span class='comment'>// from the RNG, which implements the `SplitPrf` trait.  A</span>
    <span class='comment'>// PRF, in this context, is a factory that constructs further</span>
    <span class='comment'>// `SplitRng`s.</span>
    <span class='kw'>let</span> <span class='ident'>prf</span>: <span class='ident'>SipPrf</span> <span class='op'>=</span> <span class='ident'>rng</span>.<span class='ident'>splitn</span>();
 
    <span class='comment'>// Now we pick a random index, and call the PRF four times</span>
    <span class='comment'>// with that index.</span>
    <span class='kw'>let</span> <span class='ident'>i</span>: <span class='ident'>u64</span> <span class='op'>=</span> <span class='ident'>rng</span>.<span class='ident'>next_u64</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ra</span>: <span class='ident'>SipRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rb</span>: <span class='ident'>SipRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rc</span>: <span class='ident'>SipRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rd</span>: <span class='ident'>SipRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
 
    <span class='comment'>// A PRF is a deterministic function from the index into fresh</span>
    <span class='comment'>// RNG instances.  So the four RNGs we just constructed are</span>
    <span class='comment'>// guaranteed to be in the same initial state.  (Note that this</span>
    <span class='comment'>// can be used to randomly generate pure functions!)</span>
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>ra</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                    <span class='ident'>rb</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>rc</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                    <span class='ident'>rd</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>ra</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                    <span class='ident'>rc</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>rb</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                    <span class='ident'>rd</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
 
 
    <span class='comment'>// We pick two distinct types that implement the `SplitRand`</span>
    <span class='comment'>// trait.  We choose them so that generating a value of each</span>
    <span class='comment'>// type advances the state of a sequential RNG by a different</span>
    <span class='comment'>// amount than the other.</span>
    <span class='kw'>type</span> <span class='ident'>T0</span> <span class='op'>=</span> [<span class='ident'>u64</span>; <span class='number'>16</span>];
    <span class='kw'>type</span> <span class='ident'>T1</span> <span class='op'>=</span> [<span class='ident'>u64</span>; <span class='number'>32</span>];
 
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>100</span> {
        <span class='comment'>// Now we use our four initially-identical RNGs to</span>
        <span class='comment'>// generate tuples representing all four combinations of</span>
        <span class='comment'>// our two element types:</span>
        <span class='kw'>let</span> (<span class='ident'>a0</span>, <span class='ident'>a1</span>): (<span class='ident'>T0</span>, <span class='ident'>T0</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>ra</span>);
        <span class='kw'>let</span> (<span class='ident'>b0</span>, <span class='ident'>b1</span>): (<span class='ident'>T0</span>, <span class='ident'>T1</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rb</span>);
        <span class='kw'>let</span> (<span class='ident'>c0</span>, <span class='ident'>c1</span>): (<span class='ident'>T1</span>, <span class='ident'>T0</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rc</span>);
        <span class='kw'>let</span> (<span class='ident'>d0</span>, <span class='ident'>d1</span>): (<span class='ident'>T1</span>, <span class='ident'>T1</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rd</span>);
         
        <span class='comment'>// And here we test that the value of each element</span>
        <span class='comment'>// generated depends on its type and its position within</span>
        <span class='comment'>// its pair, but not on what was generated for the other</span>
        <span class='comment'>// element.</span>
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a0</span>, <span class='ident'>b0</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a1</span>, <span class='ident'>c1</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>b1</span>, <span class='ident'>d1</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c0</span>, <span class='ident'>d0</span>);
 
        <span class='comment'>// Finally, note that we&#39;re doing this inside of a loop</span>
        <span class='comment'>// and reusing the same four generators for each</span>
        <span class='comment'>// iteration.  So at this point all four generators must</span>
        <span class='comment'>// be in the same state for subsequent iterations to pass.</span>
    }
}
</pre>

<p>This can be useful in programs that generate complex pseudo-random
data from fixed seeds, because it means that changes in one
location of the program can be made much less likely to affect the
results produced in others.  It can also be useful in parallel
programs, because it can be used to provide deterministic
pseudo-random generation in spite of non-deterministic execution
order.</p>

<h2 id='references' class='section-header'><a href='#references'>References:</a></h2>
<ul>
<li>Claessen, Koen and Michał H. Pałka.  2013.  <a href="http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf">&quot;Splittable
Pseudorandom Number Generators using Cryptographic
Hashing.&quot;</a>
<em>Haskell &#39;13: Proceedings of the 2013 ACM SIGPLAN symposium on
Haskell</em>, pp. 47-58.</li>
<li>Schaathun, Hans Georg.  2015.  <a href="http://www.hg.schaathun.net/research/Papers/hgs2015jfp.pdf">&quot;Evaluation of Splittable
Pseudo-Random
Generators.&quot;</a>
<em>Journal of Functional Programming</em>, Vol. 25.</li>
<li>The Haskell <a href="https://hackage.haskell.org/package/tf-random"><code>tf-random</code> library</a>.</li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='mod' href='generic/index.html'
                                  title='rand_split::generic'>generic</a></td>
                           <td class='docblock short'>
                                <p>A construction that turns a pair of a splittable and a sequential
PRNG into a splittable PRNG.  The intent of this is to gain the
splittability of the former but retain the sequential generation
speed of the latter.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='siprng/index.html'
                                  title='rand_split::siprng'>siprng</a></td>
                           <td class='docblock short'>
                                <p>A splittable pseudo-random number generator based on the
SipHash function.  <strong>This is not intended to be a
cryptographically secure PRNG.</strong></p>
                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.split_rand_seq_impl!.html'
                                  title='rand_split::split_rand_seq_impl!'>split_rand_seq_impl!</a></td>
                           <td class='docblock short'>
                                <p>A macro that implements <code>SplitRand</code> sequentially for any type that
has a <code>Rand</code> implementation, simply by using that.  This is meant
to be used for &quot;atomic&quot; types whose generation doesn&#39;t benefit
from splittability.</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.SplitPrf.html'
                                  title='rand_split::SplitPrf'>SplitPrf</a></td>
                           <td class='docblock short'>
                                <p>Pseudo-random functions (&quot;PRFs&quot;) generated off a <code>SplitRng</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.SplitRand.html'
                                  title='rand_split::SplitRand'>SplitRand</a></td>
                           <td class='docblock short'>
                                <p>A type that can be randomly generated from a <code>SplitRand</code>.
Implementations are expected to exploit splittability where
possible.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.SplitRng.html'
                                  title='rand_split::SplitRng'>SplitRng</a></td>
                           <td class='docblock short'>
                                <p>A trait for <strong>splittable</strong> pseudo random generators.</p>
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.Prf.html'
                                  title='rand_split::Prf'>Prf</a></td>
                           <td class='docblock short'>
                                <p>The pseudo-random functions of a generic <code>Split</code> RNG.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.Split.html'
                                  title='rand_split::Split'>Split</a></td>
                           <td class='docblock short'>
                                <p>A wrapper that generically adds splittability to RNGs.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rand_split";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>