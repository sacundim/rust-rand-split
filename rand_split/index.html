<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `rand_split` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, rand_split">

    <title>rand_split - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'rand_split', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>rand_split</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/rand_split/src/lib.rs.html#10-549' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Splittable pseudo-random number generators.</p>

<p>These are generators that support a <strong>split</strong> operations that
forks one or more &quot;child&quot; generators off the parent.  Children&#39;s
initial states depend on the source RNG&#39;s state, but they produce
outputs that are uncorrelated to each other.  This can be useful
in some contexts:</p>

<ul>
<li>Functional programs sometimes make good use of splittable RNGs.  The
Haskell <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> 
library is a notable example that uses a splittable, pure-functional
PRNG to support random generation of deterministic functions.</li>
<li>Parallel programs may benefit from a splittable PRNG.  The
advantage isn&#39;t necessarily performance but rather
<strong>reproducibility</strong>; it makes it easier to guarantee that using
the same seed yields the same results even if the execution order
is nondeterministic.</li>
</ul>

<h2 id='motivation' class='section-header'><a href='#motivation'>Motivation</a></h2>
<p>Splittable PRNGs offer superior <strong>reproducibility</strong> in some
scenarios.  Consider a case where you are randomly generating a
pair of <code>Rand</code> instances with a conventional, i.e. <strong>sequential</strong>
PRNG:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;
<span class='kw'>use</span> <span class='ident'>rand</span>::{<span class='ident'>Rng</span>, <span class='ident'>SeedableRng</span>, <span class='ident'>XorShiftRng</span>, <span class='ident'>Rand</span>, <span class='ident'>thread_rng</span>};

<span class='comment'>// Make two PRNGs from the same seed.</span>
<span class='kw'>let</span> <span class='ident'>seed</span>: [<span class='ident'>u32</span>; <span class='number'>4</span>] <span class='op'>=</span> <span class='ident'>thread_rng</span>().<span class='ident'>gen</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rng0</span>: <span class='ident'>XorShiftRng</span> <span class='op'>=</span> <span class='ident'>SeedableRng</span>::<span class='ident'>from_seed</span>(<span class='ident'>seed</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rng1</span>: <span class='ident'>XorShiftRng</span> <span class='op'>=</span> <span class='ident'>SeedableRng</span>::<span class='ident'>from_seed</span>(<span class='ident'>seed</span>);
 
<span class='kw'>type</span> <span class='ident'>T0</span> <span class='op'>=</span> [<span class='ident'>u64</span>; <span class='number'>16</span>];
<span class='kw'>type</span> <span class='ident'>T1</span> <span class='op'>=</span> [<span class='ident'>u64</span>; <span class='number'>32</span>];
<span class='kw'>let</span> (_, <span class='ident'>a</span>): (<span class='ident'>T0</span>, <span class='ident'>T0</span>) <span class='op'>=</span> <span class='ident'>Rand</span>::<span class='ident'>rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rng0</span>);
<span class='kw'>let</span> (_, <span class='ident'>b</span>): (<span class='ident'>T1</span>, <span class='ident'>T0</span>) <span class='op'>=</span> <span class='ident'>Rand</span>::<span class='ident'>rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rng1</span>);

<span class='comment'>// This should fail, unless you&#39;re crazy unlucky:</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, <span class='ident'>b</span>); </pre>

<p>With a sequential generator, the way this is generated typically
is so:</p>

<ol>
<li>The <code>rng</code> starts at some initial state.  Call this state <code>s0</code>.</li>
<li>We use <code>rng</code> to generate a random <code>a</code>.  This leaves the <code>rng</code>
in some state, call it <code>s1</code>.</li>
<li>We reuse <code>rng</code> to generate a random <code>b</code>.  This leaves the <code>rng</code>
in some state, call it <code>s2</code>.</li>
</ol>

<p>Now, if the logic that generates the <code>a</code> value changes, then
states <code>s1</code> may end up different even if we start from the same
<code>s0</code>, which means that the value generated for <code>b</code> may also
change.</p>

<p>With a splittable PRNG, you can generate the tuple&#39;s elements with
<strong>independent</strong> PRNGs split off the parent, so that changes to the
logic that generates one element cannot affect the other.  This
can be illustrated with our flagship unit test:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand_split</span>;

<span class='kw'>use</span> <span class='ident'>rand</span>::{<span class='ident'>Rng</span>, <span class='ident'>Isaac64Rng</span>, <span class='ident'>thread_rng</span>};
<span class='kw'>use</span> <span class='ident'>rand_split</span>::{<span class='ident'>SplitRng</span>, <span class='ident'>SplitPrf</span>, <span class='ident'>SplitRand</span>, <span class='ident'>Split</span>, <span class='ident'>Prf</span>};

<span class='comment'>// We will be using the `rand` crate&#39;s `Isaac64Rng`, but</span>
<span class='comment'>// wrapped with a `Split` wrapper that adds splittability</span>
<span class='comment'>// on top of it.</span>
<span class='kw'>type</span> <span class='ident'>OurRng</span> <span class='op'>=</span> <span class='ident'>Split</span><span class='op'>&lt;</span><span class='ident'>Isaac64Rng</span><span class='op'>&gt;</span>;
<span class='kw'>type</span> <span class='ident'>OurPrf</span> <span class='op'>=</span> <span class='ident'>Prf</span><span class='op'>&lt;</span><span class='ident'>Isaac64Rng</span><span class='op'>&gt;</span>;

<span class='comment'>// The library&#39;s RNGs have `Rand` instances, so we can get</span>
<span class='comment'>// a randomly seeded RNG this way:</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rng</span>: <span class='ident'>OurRng</span> <span class='op'>=</span> <span class='ident'>thread_rng</span>().<span class='ident'>gen</span>();

<span class='comment'>// We split off a **pseudo-random function** (&quot;PRF&quot;) from</span>
<span class='comment'>// the RNG.  PRFs implement the `SplitPrf` trait.</span>
<span class='kw'>let</span> <span class='ident'>prf</span>: <span class='ident'>OurPrf</span> <span class='op'>=</span> <span class='ident'>rng</span>.<span class='ident'>splitn</span>();
 
<span class='comment'>// PRFs serve as factories that construct further `SplitRng`s.</span>
<span class='comment'>// So now we pick a random index and call the PRF four times</span>
<span class='comment'>// with that index to get four new RNGs.</span>
<span class='kw'>let</span> <span class='ident'>i</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>rng</span>.<span class='ident'>gen</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ra</span>: <span class='ident'>OurRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rb</span>: <span class='ident'>OurRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rc</span>: <span class='ident'>OurRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rd</span>: <span class='ident'>OurRng</span> <span class='op'>=</span> <span class='ident'>prf</span>.<span class='ident'>call</span>(<span class='ident'>i</span>);
 
<span class='comment'>// A PRF is a function that captures a &quot;frozen&quot; state from</span>
<span class='comment'>// its parent RNG, and constructs further RNG instances </span>
<span class='comment'>// whose initial states depend only on that frozen state and </span>
<span class='comment'>// the index supplied to `call`.  So the four RNGs we just</span>
<span class='comment'>// constructed are guaranteed to be in the same initial state.</span>
<span class='comment'>// And behold, they produce identical outputs!</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>ra</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                <span class='ident'>rb</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>rc</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                <span class='ident'>rd</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>ra</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                <span class='ident'>rc</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>iter_eq</span>(<span class='ident'>rb</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>),
                <span class='ident'>rd</span>.<span class='ident'>gen_ascii_chars</span>().<span class='ident'>take</span>(<span class='number'>100</span>)));
 
<span class='comment'>// Now for the main course.  We pick two distinct types that</span>
<span class='comment'>// implement the `SplitRand` trait.  We choose them so that</span>
<span class='comment'>// generating a value of either type advances the state of a</span>
<span class='comment'>// sequential RNG by a different amount than the other.</span>
<span class='kw'>type</span> <span class='ident'>T0</span> <span class='op'>=</span> [<span class='ident'>u64</span>; <span class='number'>16</span>];
<span class='kw'>type</span> <span class='ident'>T1</span> <span class='op'>=</span> [<span class='ident'>u64</span>; <span class='number'>32</span>];
 
<span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>100</span> {
    <span class='comment'>// Then we use our four initially-identical RNGs to</span>
    <span class='comment'>// generate tuples representing all four combinations of</span>
    <span class='comment'>// our two element types:</span>
    <span class='kw'>let</span> (<span class='ident'>a0</span>, <span class='ident'>a1</span>): (<span class='ident'>T0</span>, <span class='ident'>T0</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>ra</span>);
    <span class='kw'>let</span> (<span class='ident'>b0</span>, <span class='ident'>b1</span>): (<span class='ident'>T0</span>, <span class='ident'>T1</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rb</span>);
    <span class='kw'>let</span> (<span class='ident'>c0</span>, <span class='ident'>c1</span>): (<span class='ident'>T1</span>, <span class='ident'>T0</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rc</span>);
    <span class='kw'>let</span> (<span class='ident'>d0</span>, <span class='ident'>d1</span>): (<span class='ident'>T1</span>, <span class='ident'>T1</span>) <span class='op'>=</span> <span class='ident'>SplitRand</span>::<span class='ident'>split_rand</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>rd</span>);
     
    <span class='comment'>// And here we test that the value of each element</span>
    <span class='comment'>// generated depends on its type and its position within</span>
    <span class='comment'>// its pair, but not on what was generated for the other</span>
    <span class='comment'>// element.</span>
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a0</span>, <span class='ident'>b0</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a1</span>, <span class='ident'>c1</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>b1</span>, <span class='ident'>d1</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>c0</span>, <span class='ident'>d0</span>);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a0</span> <span class='op'>!=</span> <span class='ident'>a1</span>);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a0</span> <span class='op'>!=</span> <span class='ident'>c1</span>);
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>d0</span> <span class='op'>!=</span> <span class='ident'>d1</span>);
 
    <span class='comment'>// Finally, note that we&#39;re doing this inside of a loop</span>
    <span class='comment'>// and reusing the same four RNGs on each iteration.  So </span>
    <span class='comment'>// at this point all four generators must end the same</span>
    <span class='comment'>// state or subsequent iterations will fail.</span>
}</pre>

<p>This can be useful in programs that generate complex pseudo-random
data from fixed seeds, because it means that changes in one
location of the program can be made much less likely to affect the
results produced in others.  It can also be useful in parallel
programs, because it can be used to provide deterministic
pseudo-random generation in spite of non-deterministic execution
order.</p>

<h2 id='references' class='section-header'><a href='#references'>References</a></h2>
<ul>
<li>Claessen, Koen and Michał H. Pałka.  2013.  <a href="http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf">&quot;Splittable
Pseudorandom Number Generators using Cryptographic
Hashing.&quot;</a>
<em>Haskell &#39;13: Proceedings of the 2013 ACM SIGPLAN symposium on
Haskell</em>, pp. 47-58.</li>
<li>Schaathun, Hans Georg.  2015.  <a href="http://www.hg.schaathun.net/research/Papers/hgs2015jfp.pdf">&quot;Evaluation of Splittable
Pseudo-Random
Generators.&quot;</a>
<em>Journal of Functional Programming</em>, Vol. 25.</li>
<li>The Haskell <a href="https://hackage.haskell.org/package/tf-random"><code>tf-random</code> library</a>.</li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='mod' href='generic/index.html'
                                  title='rand_split::generic'>generic</a></td>
                           <td class='docblock short'>
                                <p>A construction that turns a pair of a splittable and a sequential
PRNG into a splittable PRNG.  The intent of this is to gain the
splittability of the former but retain the sequential generation
speed of the latter.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='siprng/index.html'
                                  title='rand_split::siprng'>siprng</a></td>
                           <td class='docblock short'>
                                <p>A splittable pseudo-random number generator based on the
SipHash function.  <strong>This is not intended to be a
cryptographically secure PRNG.</strong></p>
                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='macro' href='macro.split_rand_seq_impl!.html'
                                  title='rand_split::split_rand_seq_impl!'>split_rand_seq_impl!</a></td>
                           <td class='docblock short'>
                                <p>A macro that implements <code>SplitRand</code> sequentially for any type that
has a <code>Rand</code> implementation, simply by using that.  This is meant
to be used for &quot;atomic&quot; types whose generation doesn&#39;t benefit
from splittability.</p>
                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Seq.html'
                                  title='rand_split::Seq'>Seq</a></td>
                           <td class='docblock short'>
                                <p>A newtype wrapper to add a <code>SplitRand</code> implementation to <code>Rand</code>
types.  This just does the same thing as the base type&#39;s <code>Rand</code>
one does.</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.SplitPrf.html'
                                  title='rand_split::SplitPrf'>SplitPrf</a></td>
                           <td class='docblock short'>
                                <p>Pseudo-random functions (&quot;PRFs&quot;) generated off a <code>SplitRng</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.SplitRand.html'
                                  title='rand_split::SplitRand'>SplitRand</a></td>
                           <td class='docblock short'>
                                <p>A type that can be randomly generated from a <code>SplitRand</code>.
Implementations are expected to exploit splittability where
possible.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='trait' href='trait.SplitRng.html'
                                  title='rand_split::SplitRng'>SplitRng</a></td>
                           <td class='docblock short'>
                                <p>A trait for <strong>splittable</strong> pseudo random generators.</p>
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.Prf.html'
                                  title='rand_split::Prf'>Prf</a></td>
                           <td class='docblock short'>
                                <p>The pseudo-random functions of a generic <code>Split</code> RNG.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='type' href='type.Split.html'
                                  title='rand_split::Split'>Split</a></td>
                           <td class='docblock short'>
                                <p>A wrapper that generically adds splittability to RNGs.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rand_split";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>